# -*- coding: utf-8 -*-
"""TateShorts.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OdY0bIgrRSMTST1BPDj_NnT-EmjJQs2g

# Imports
"""
import os, sys
import requests
import urllib.request
import re
import subprocess
import shlex
import random
import ffmpeg
import srt
import datetime
import json
import math
import google.auth
import io

from pytube import YouTube
from google.protobuf.json_format import MessageToJson
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from apiclient.discovery import build
from google.cloud import speech

"""# Downloading"""

def downloadBackground(URLs):
  for url in URLs:
    yt = YouTube(url)
    title = yt.title.replace(" ","-")
    if os.path.exists('./' + title + '.mp4'):
      print("Background " + title + " --> Already Downloaded")
    else:
      video_stream = yt.streams.filter(file_extension='mp4').get_highest_resolution()
      video_stream.download(filename=title + '.mp4')
      getMutedBackground('./' + title + '.mp4')   
      print("Background " + title + " --> Successfully Downloaded")

def downloadMP4FromURL(video_url,video_name):
  # Send an HTTP GET request to the URL
  response = requests.get(video_url)

  # Check the status code of the response
  if response.status_code == 200:
    # Write the content of the response to a file
    dir = './' + video_name.split('.mp4')[0]
    os.makedirs(dir)
    with open(dir + '/' + video_name, 'wb') as f:
        f.write(response.content)
        print('Video Succesfully Downloaded')
  else:
    print('Failed to download video')

def getDOMTree(link_url,video_name):

  if os.path.exists('./' + video_name.split('.mp4')[0]):
    print('Video Already Downloaded')
  else:
    #HAVE TO MASK AS USER SO DOMAIN DOESN'T RECOGNIZE WEB SCRAPER
    HEADERS = {'User-Agent': 'Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148'}
    r = requests.get(link_url,headers=HEADERS)
    index = r.text.find('contentUrl')

    if index != -1:
      # Get the line that contains the string by slicing the text
      line = r.text[index:].split('\n')[0]
      match = re.search(r'contentUrl": "(.+?)"', line)

      # Check if a match was found
      if match:
        # Get the URL from the match object
        url = match.group(1)
        downloadMP4FromURL(url,video_name)
      else:
        print('URL not found')
    else:
      print('String not found')

def fix_timestamp(timestamp):
  # Use a regular expression to check if the timestamp starts with '00:'
  if not re.match(r'^00:', timestamp):
    # If the timestamp does not start with '00:', add it to the beginning
    timestamp = '00:' + timestamp
  return timestamp + '.000'

"""# Cropping"""

def cropVideo(video_name, backgroundPath):

  outputPath = './' + video_name.split('.mp4')[0]
  inputFile = outputPath + '/' + video_name

  startTime = input("Enter Start Timestamp: ")
  endTime = input("Enter End Timestamp: ")
  fileName = startTime + '-' + endTime + '.mp4'

  startTime = fix_timestamp(startTime)
  endTime = fix_timestamp(endTime)

  # 20 represents the quality/filesize ratio. 0 is best quality. 51 is worst quality.
  command = ['ffmpeg', '-i', inputFile, '-copyinkf', '-ss', startTime, '-to', endTime, '-vf', 'scale=1080:960,setsar=9/16', '-c:v', 'libx264', '-crf', '20', '-c:a', 'copy','-y', f'{outputPath}/tateClip.mp4']
  subprocess.run(command)

  backgroundLength = getVideoLength(backgroundPath)
  vidLength = getVideoLength(f'{outputPath}/tateClip.mp4')
  
  backgroundStart = getRandomNumber(30, backgroundLength - vidLength - 30)

  command = ['ffmpeg', '-i', backgroundPath, '-copyinkf', '-ss', getHHMMSS(backgroundStart), '-to', getHHMMSS(backgroundStart + vidLength), '-vf', 'scale=1080:960,setsar=9/16', '-c:v', 'libx264', '-crf', '20', '-c:a', 'copy','-y', './background.mp4']
  subprocess.run(command)

  command = [
      "ffmpeg",
      "-i",
      f'{outputPath}/tateClip.mp4',
      "-i",
      './background.mp4',
      "-filter_complex",
      "[0:v]scale=iw:ih/2[top];[1:v]scale=iw:ih/2[bottom];[top][bottom]vstack,setdar=9/16,format=yuv420p",
      "-c:v",
      "libx264",
      "-crf",
      "20",
      f'{outputPath}/{fileName}'
  ]
  subprocess.run(command)

  # os.remove(f'{outputPath}/tateClip.mp4')
  os.remove('./background.mp4')

  return outputPath, f'{outputPath}/{fileName}'

def getVideoLength(video_path):
	command = ['ffprobe', '-v', 'fatal', '-show_entries', 'stream=width,height,r_frame_rate,duration', '-of', 'default=noprint_wrappers=1:nokey=1', video_path]
	ffmpeg = subprocess.Popen(command, stderr=subprocess.PIPE,stdout = subprocess.PIPE )
	out, err = ffmpeg.communicate()

	if err:
		print(err)
	
	return int((out.decode().split('\n')[3]).split('.')[0])

def getMutedBackground(video_path):
  muted_video_path = './muted.mp4'
  command = "ffmpeg -i " + video_path + " -c copy -an -y " + muted_video_path
  print(command)
  try:
    os.system(command)
    os.remove(video_path)
    os.rename(muted_video_path,video_path)  
  except:
    print("getMutedBackground failed")

def getSeconds(timestamp):
  dt = datetime.datetime.strptime(timestamp, "%H:%M:%S.%f")
  return dt.hour*3600 + dt.minute*60 + dt.second

def getHHMMSS(timestamp):
  dt = datetime.datetime.utcfromtimestamp(int(timestamp))
  return dt.strftime('%H:%M:%S') + '.000'

def getRandomNumber(a, b):
  # Get a random integer between a and b (inclusive)
  return random.randint(a, b)

"""# Audio Transcription"""
def getWordTime(secondsTime):
	return float(secondsTime.split('s')[0])

def mp4ToAudio(clipDir):
	command = "ffmpeg -i {} -c:a flac -y {}".format(clipDir + '/tateClip.mp4',clipDir + '/tateSound.flac')
	try:
		ret = subprocess.call(command, shell=True)
		print("Extracted audio to {}/{}".format(clipDir,'tateSound.flac'))
	except Exception as e:
		print("Error: ", str(e))
		exit(1)

	return clipDir + '/tateSound.flac'

# Example: call the Cloud Speech-to-Text API to transcribe an audio file
def transcribe_file(speech_file):
	client = speech.SpeechClient()

	with io.open(speech_file, "rb") as audio_file:
		content = audio_file.read()

	audio = speech.RecognitionAudio(content=content)
	config = speech.RecognitionConfig(
		encoding=speech.RecognitionConfig.AudioEncoding.FLAC,
		sample_rate_hertz=44100,
		language_code="en-US",
		audio_channel_count = 2,
		model = "latest_short",
		enable_word_time_offsets= True,
	)

	response = client.recognize(config=config, audio=audio)
	response = json.loads(MessageToJson(response._pb))
	
	makeSubtitlesFile(response)

def makeSubtitlesFile(response):
	entries = []
	contentBuffer = ""
	window_s, window_f = -1, -1 
	segment_duration = 0.18
	index = 1
	
	for result in response.get("results"):
		for word in result.get("alternatives")[0].get("words"):

			start_time = getWordTime(word.get("startTime"))
			end_time = getWordTime(word.get("endTime"))
			content = word.get("word")

			contentBuffer += content + " "

			if end_time - start_time > 0.2:
				start_time = end_time - 0.2
			# Initializer
			if window_s == -1:
				window_s, window_f = start_time, start_time + segment_duration

			if end_time > window_f:
				entry = srt.Subtitle(index = index, start = datetime.timedelta(seconds=int(window_s),milliseconds=int((window_s - math.floor(window_s))*1000)),end = datetime.timedelta(seconds=int(end_time),milliseconds=int((end_time - math.floor(end_time))*1000)), content = contentBuffer)
				entries.append(entry)
				window_s, window_f = -1, -1
				contentBuffer = ""
				index += 1

	subtitle_file = "./tateSubtitles.srt"

	with open(subtitle_file, "w") as subtitle_file:
		subtitle_file.write(srt.compose(entries))

	return subtitle_file

def generateVisualSubtitles(clipPath, subtitle_file):
	subtitles = "subtitles={}:fontsdir='/usr/share/fonts/truetype/ubuntu':force_style='Alignment=10,FontName=Impacted,FontSize=32,PrimaryColour=&H00FFFFFF'".format(subtitle_file)
	print(subtitles)
	command = 'ffmpeg -i {} -vf "{}" -c:v libx264 -crf 18 -c:a copy -y tateOutput.mp4'.format(clipPath, subtitles)

	os.system(command)
	print("Successfully created video at tateOutput.mp4")

"""# User Action Required"""

#@title Video Game Backgrounds

# Concatenate background Youtube links to this array
URLs = ['https://youtu.be/9NgBLirYQS8']
downloadBackground(URLs)

#@title URL Input
# https://odysee.com/@tatespeech:c/superbike-vs-supercar:1
link_url = input("Enter Odysee Link URL: ")
backgroundPath = './Forza-Horizon-4-DRIVING-LIKE-A-BOSS!!-1876HP-RTR-Mustang.mp4'

#@title User Actions From URL Input
video_name = link_url.rsplit('/',1)[-1] + '.mp4'

# Downloads the correspondent Andrew Tate video
# Creates a repository, and stores .mp4 file
# If already downloaded, then skipped
getDOMTree(link_url,video_name)

# Crops both the background .mp4, and the Andrew Tate .mp4. Vertically concatenates them to be 9:16.
# Returns filepath of the video that contains the conjoined background .mp4 + Tate .mp4
clipDir, clipPath = cropVideo(video_name,backgroundPath)

generateVisualSubtitles(clipPath, transcribe_file(mp4ToAudio(clipDir)))

